<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Explicit Font Adjuster Example - UIstate Documentation</title>
  <link rel="stylesheet" href="main.css">
  <style>
    .demo-container {
      border: 1px solid #e0e0e0;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      background-color: #f9f9f9;
    }
    
    .code-example {
      background-color: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
    }
    
    .code-example pre {
      margin: 0;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Explicit Font Adjuster Example</h1>
      <p>Using explicit state selectors for typography control</p>
    </div>
  </header>

  <div class="container">
    <nav class="breadcrumbs">
      <a href="../index.html">Home</a> &gt;
      <a href="../examples.html">Examples</a> &gt;
      <span>Explicit Font Adjuster</span>
    </nav>

    <main>
    <section class="intro">
      <h2>Introduction</h2>
      <p>
        The Explicit Font Adjuster demonstrates the "oddly satisfying" approach to state management
        using explicit CSS selectors for each possible font size value. This approach trades verbosity
        for clarity and performance, with no runtime calculations required for state derivation.
      </p>
      <p>
        Instead of using ranges or calculations to determine font styling, this example defines
        every possible state explicitly in CSS. While this results in more verbose CSS, it provides
        exceptional clarity, predictability, and performance since no runtime calculations are needed.
      </p>
    </section>

    <section class="demo">
      <h2>Live Demo</h2>
      <div class="demo-container">
        <iframe src="../../examples/basic/explicit-font-adjuster/index.html" width="100%" height="450" frameborder="0"></iframe>
      </div>
      <p class="demo-link">
        <a href="../../examples/basic/explicit-font-adjuster/index.html" target="_blank">Open in new tab</a>
      </p>
    </section>

    <section class="implementation">
      <h2>Implementation Walkthrough</h2>
      
      <h3>HTML Structure</h3>
      <p>
        The font adjuster interface consists of size categories, a slider control, value display, and a preview panel.
        The root container element stores the current font size as a <code>data-uis-value</code> attribute.
      </p>
      <div class="code-example">
        <pre><code>&lt;div class="explicit-adjuster-container" data-uis-value="16"&gt;
  &lt;div class="size-categories"&gt;
    &lt;div class="size-category" data-category="small"&gt;&lt;span class="category-label"&gt;Small&lt;/span&gt;&lt;/div&gt;
    &lt;div class="size-category" data-category="medium"&gt;&lt;span class="category-label"&gt;Medium&lt;/span&gt;&lt;/div&gt;
    &lt;div class="size-category" data-category="large"&gt;&lt;span class="category-label"&gt;Large&lt;/span&gt;&lt;/div&gt;
    &lt;div class="size-category" data-category="x-large"&gt;&lt;span class="category-label"&gt;X-Large&lt;/span&gt;&lt;/div&gt;
  &lt;/div&gt;
  
  &lt;div class="slider-track"&gt;
    &lt;div class="slider-fill"&gt;&lt;/div&gt;
    &lt;div class="slider-thumb"&gt;&lt;/div&gt;
  &lt;/div&gt;
  
  &lt;div class="value-display"&gt;
    &lt;div class="current-value"&gt;&lt;span id="size-value"&gt;16&lt;/span&gt;px&lt;/div&gt;
    &lt;div class="current-category"&gt;&lt;/div&gt;
  &lt;/div&gt;
  
  &lt;div class="font-preview-panel"&gt;
    &lt;h3&gt;Text Preview&lt;/h3&gt;
    &lt;div class="font-preview"&gt;
      &lt;p&gt;The quick brown fox jumps over the lazy dog...&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
      </div>
      
      <h3>State Management with Explicit Selectors</h3>
      <p>
        The key feature of this example is the use of explicit CSS selectors for each possible
        font size value (8px to 32px). Each selector defines specific style properties for that exact size value.
      </p>
      <div class="code-example">
        <pre><code>/* Small Size Category: 8-12px */
.explicit-adjuster-container[data-uis-value="8"],
.explicit-adjuster-container[data-uis-value="9"],
.explicit-adjuster-container[data-uis-value="10"],
.explicit-adjuster-container[data-uis-value="11"],
.explicit-adjuster-container[data-uis-value="12"] {
  --font-category: "small";
  --category-color: #95a5a6;
  --category-icon: url("data:image/svg+xml,...");
}

/* Individual size-specific enhancements */
.explicit-adjuster-container[data-uis-value="8"] {
  --letter-spacing: -0.03em;
  --line-height: 1.3;
}

.explicit-adjuster-container[data-uis-value="9"] {
  --letter-spacing: -0.025em;
  --line-height: 1.3;
}

/* And so on for each value... */</code></pre>
      </div>
      
      <h3>JavaScript Interaction</h3>
      <p>
        The JavaScript code handles user interactions like dragging the slider or clicking on categories,
        updating the <code>data-uis-value</code> attribute accordingly:
      </p>
      <div class="code-example">
        <pre><code>// Update the attribute
container.setAttribute('data-uis-value', newValue);

// Update the UI
updateSliderPosition();
updateFontSize();</code></pre>
      </div>
    </section>

    <section class="key-insights">
      <h2>Key Insights</h2>
      
      <h3>Verbose but Performant</h3>
      <p>
        The explicit approach results in more CSS code but offers several advantages:
      </p>
      <ul>
        <li><strong>Zero Runtime Calculations:</strong> No math is required at runtime to derive styles</li>
        <li><strong>Predictable Behavior:</strong> Each state is explicitly defined with no edge cases</li>
        <li><strong>Direct Inspection:</strong> Easy to inspect and debug since each value has its own selector</li>
        <li><strong>Fine-Grained Control:</strong> Each value can have unique styling properties</li>
      </ul>
      
      <h3>When to Use This Approach</h3>
      <p>
        The explicit approach works best when:
      </p>
      <ul>
        <li>You have a finite, reasonable number of possible values</li>
        <li>Each value needs precise, potentially unique styling</li>
        <li>Performance is critical and you want to minimize runtime calculations</li>
        <li>You prefer clarity and debuggability over code brevity</li>
      </ul>
      
      <h3>State as a Source of Truth</h3>
      <p>
        This example demonstrates how a simple attribute (<code>data-uis-value</code>) can serve
        as a single source of truth. The attribute drives all visual aspects of the interface,
        including:
      </p>
      <ul>
        <li>The category highlighting</li>
        <li>The slider position</li>
        <li>The font size and typography properties</li>
        <li>The descriptive text and icons</li>
      </ul>
    </section>

    <section class="next-steps">
      <h2>Taking It Further</h2>
      
      <h3>Optimizing CSS Volume</h3>
      <p>
        While the explicit approach has advantages, the CSS can become unwieldy with large numbers of values.
        Consider these optimization techniques:
      </p>
      <ul>
        <li>Use a CSS preprocessor like Sass to generate the explicit selectors</li>
        <li>Group values with identical properties to reduce duplication</li>
        <li>Consider a hybrid approach with some calculations for values that follow patterns</li>
      </ul>
      
      <h3>Enhanced Accessibility</h3>
      <p>
        The example could be enhanced with better accessibility features:
      </p>
      <ul>
        <li>Add ARIA attributes to the slider for screen reader support</li>
        <li>Implement keyboard controls for adjusting the font size</li>
        <li>Include high-contrast mode support</li>
      </ul>
      
      <h3>Persistence and Integration</h3>
      <p>
        Build upon this example by:
      </p>
      <ul>
        <li>Storing the selected font size in localStorage for persistence across page loads</li>
        <li>Creating a site-wide typography system based on this approach</li>
        <li>Connecting it to a theme system for comprehensive styling control</li>
        <li>Exploring how this approach could work with design tokens</li>
      </ul>
      
      <h3>Compare with Domain Approach</h3>
      <p>
        Explore the differences between this explicit approach and the <a href="domain-font-adjuster.html">Domain Font Adjuster</a>
        example, which takes a different approach to the same problem using domain-based state management.
      </p>
    </section>
    </main>
  </div>

  <footer>
    <div class="container">
      <p>&copy; 2025 UIstate - A declarative state management approach for the web</p>
    </div>
  </footer>
</body>
</html>
