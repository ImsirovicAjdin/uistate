<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Domain State Slider Example - UIstate Documentation</title>
  <link rel="stylesheet" href="main.css">
  <style>
    .demo-container {
      border: 1px solid #e0e0e0;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      background-color: #f9f9f9;
    }
    
    .code-example {
      background-color: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
    }
    
    .code-example pre {
      margin: 0;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Domain State Slider Example</h1>
      <p>Dividing continuous ranges into meaningful state domains</p>
    </div>
  </header>

  <div class="container">
    <nav class="breadcrumbs">
      <a href="../index.html">Home</a> &gt;
      <a href="../examples.html">Examples</a> &gt;
      <span>Domain State Slider</span>
    </nav>

    <main>
    <section class="intro">
      <h2>Introduction</h2>
      <p>
        This example demonstrates a novel approach to handling range-based state in UIstate 
        by dividing a continuous range into distinct domains of state that are both visually and functionally meaningful.
      </p>
      
      <h3>The Domain-Based Approach</h3>
      <p>
        The Domain State Slider represents an evolution in how we handle continuous values in UIstate. 
        Rather than trying to handle every possible value individually (which becomes unwieldy) or 
        treating the entire range as a single entity, we divide the range into meaningful domains:
      </p>
      <ul>
        <li>Each domain represents a conceptual range (e.g., "low", "medium", "high")</li>
        <li>Domains have clear visual and functional boundaries</li>
        <li>State derivation happens at two levels: which domain is active, and where within the domain the value sits</li>
      </ul>
      
      <h3>Advantages Over Other Approaches</h3>
      <p>
        This approach combines the best aspects of both CSS-derived and attribute-derived sliders:
      </p>
      <ul>
        <li><strong>Reduced Complexity</strong> - No need to list every possible value in CSS selectors</li>
        <li><strong>Clear Domain Boundaries</strong> - Visual representation makes state transitions explicit</li>
        <li><strong>Dual-Layer State</strong> - Combines discrete domain categories with continuous within-domain position</li>
        <li><strong>Self-Documenting Interface</strong> - The UI itself communicates the state structure</li>
      </ul>
      
      <h3>Example Use Cases</h3>
      <p>
        The Domain State Slider pattern is particularly useful for:
      </p>
      <ul>
        <li>Settings with meaningful intensity levels (volume, brightness, etc.)</li>
        <li>Multi-stage processes where progress falls into distinct phases</li>
        <li>Pricing or resource allocation with tiered structures</li>
        <li>Risk or priority indicators that map numeric values to semantic categories</li>
      </ul>
    </section>

    <section class="demo">
      <h2>Live Demo</h2>
      <div class="demo-container">
        <!-- Demo content will be added later -->
      </div>
    </section>

    <section class="implementation">
      <h2>Implementation Walkthrough</h2>
      
      <h3>HTML Structure</h3>
      <p>
        The Domain State Slider consists of these key elements:
      </p>
      <div class="code-example">
        <pre><code>&lt;div class="domain-slider-container" data-uis-value="50" data-uis-min="0" data-uis-max="100" data-active-domain="medium" style="--domain-position: 0.5;"&gt;
  &lt;!-- Visual representation of domains --&gt;
  &lt;div class="domain-sections"&gt;
    &lt;div class="domain-section" data-domain="muted" data-domain-start="0" data-domain-end="10"&gt;
      &lt;span class="domain-label"&gt;Muted&lt;/span&gt;
    &lt;/div&gt;
    &lt;!-- Additional domain sections... --&gt;
  &lt;/div&gt;
  
  &lt;!-- Standard slider elements --&gt;
  &lt;div class="slider-track"&gt;
    &lt;div class="slider-fill"&gt;&lt;/div&gt;
    &lt;div class="slider-thumb"&gt;&lt;/div&gt;
  &lt;/div&gt;
  
  &lt;!-- Value and feedback displays --&gt;
  &lt;div class="value-display"&gt;...&lt;/div&gt;
  &lt;div class="domain-indicator"&gt;...&lt;/div&gt;
&lt;/div&gt;</code></pre>
      </div>
      
      <p>
        Note the key data attributes that store state:
      </p>
      <ul>
        <li><code>data-uis-value</code>: The raw numeric value (source of truth)</li>
        <li><code>data-uis-min</code> and <code>data-uis-max</code>: Range boundaries</li>
        <li><code>data-active-domain</code>: The current domain category (derived state)</li>
        <li><code>style="--domain-position: 0.5;"</code>: Position within the current domain (0-1)</li>
      </ul>
      
      <h3>Domain Definition</h3>
      <p>
        Domains are defined in two places:
      </p>
      <ol>
        <li>
          <strong>In the HTML</strong> - Each domain section has attributes defining its boundaries:
          <div class="code-example">
            <pre><code>&lt;div class="domain-section" data-domain="medium" data-domain-start="31" data-domain-end="70"&gt;</code></pre>
          </div>
        </li>
        <li>
          <strong>In JavaScript</strong> - For computational purposes:
          <div class="code-example">
            <pre><code>const domains = [
  { name: 'muted', start: 0, end: 10, label: 'Muted', description: '...' },
  { name: 'low', start: 11, end: 30, label: 'Low', description: '...' },
  // Additional domains...
];</code></pre>
          </div>
        </li>
      </ol>
      
      <h3>State Derivation Process</h3>
      <p>
        When the slider value changes, we perform a two-step state derivation:
      </p>
      <div class="code-example">
        <pre><code>function updateActiveDomain() {
  const value = parseInt(container.getAttribute('data-uis-value'));
  
  // Step 1: Find which domain contains the current value
  let activeDomain = null;
  for (const domain of domains) {
    if (value >= domain.start && value <= domain.end) {
      activeDomain = domain;
      break;
    }
  }
  
  // Step 2: Set the active domain attribute (categorical derived state)
  container.setAttribute('data-active-domain', activeDomain.name);
  
  // Step 3: Calculate position within domain (continuous derived state)
  const domainRange = activeDomain.end - activeDomain.start;
  const positionInDomain = (value - activeDomain.start) / domainRange;
  container.style.setProperty('--domain-position', positionInDomain);
  
  // Additional UI updates...
}</code></pre>
      </div>
      
      <h3>CSS for Domain-Based Styling</h3>
      <p>
        The CSS uses the derived state attributes for styling:
      </p>
      <div class="code-example">
        <pre><code>/* Domain-specific base styling */
.domain-slider-container[data-active-domain="medium"] {
  --domain-color: #2980b9;
  --domain-icon: url("...");
  --domain-border: #2980b9;
}

/* Apply domain color to components */
.slider-fill {
  background-color: var(--domain-color);
  opacity: calc(0.7 + (var(--domain-position) * 0.3));
}

/* Additional component styling... */</code></pre>
      </div>
      
      <p>
        Note how we use both categorical state (<code>data-active-domain</code>) and 
        continuous state (<code>--domain-position</code>) together for rich visual effects.
      </p>
    </section>

    <section class="key-insights">
      <h2>Key Insights</h2>
      
      <h3>Bridging Continuous and Discrete State</h3>
      <p>
        The Domain State Slider represents an important conceptual breakthrough in UIstate: it bridges 
        the gap between continuous numeric values and discrete categorical states. This solves a 
        fundamental challenge in state management:
      </p>
      <ul>
        <li>Continuous values provide precision but are difficult to map directly to styles</li>
        <li>Discrete categories are easy to style but lose granularity</li>
        <li>The domain approach gives us both - categorical domains with continuous positioning within them</li>
      </ul>
      
      <h3>Conceptual Clarity Through Visual Structure</h3>
      <p>
        By making the domains visually explicit in the UI, we create a self-documenting component where:
      </p>
      <ul>
        <li>State structure is visible and tangible</li>
        <li>Transitions between states are clearly delineated</li>
        <li>The interface itself communicates the underlying state model</li>
      </ul>
      <p>
        This visual representation of state domains improves both developer and user understanding 
        of how the component behaves.
      </p>
      
      <h3>Two-Tier State Derivation</h3>
      <p>
        The Domain State Slider introduces a powerful pattern of two-tier state derivation:
      </p>
      <ol>
        <li>
          <strong>Primary Derivation</strong>: From raw value to domain category
          <div class="code-example">
            <pre><code>data-uis-value="42" → data-active-domain="medium"</code></pre>
          </div>
        </li>
        <li>
          <strong>Secondary Derivation</strong>: From domain category and position to final styling
          <div class="code-example">
            <pre><code>data-active-domain="medium" + --domain-position: 0.55 → styling effects</code></pre>
          </div>
        </li>
      </ol>
      <p>
        This layered approach to state derivation allows for both broad categorical styling and 
        fine-grained nuance within categories.
      </p>
      
      <h3>Declarative State with Pragmatic JavaScript</h3>
      <p>
        This example demonstrates the UIstate philosophy of balancing declarative state with pragmatic implementation:
      </p>
      <ul>
        <li>DOM remains the source of truth for state</li>
        <li>CSS handles styling based on declarative state attributes</li>
        <li>JavaScript is used judiciously for the specific task of deriving domain state from raw values</li>
      </ul>
      <p>
        Rather than forcing CSS to handle numeric comparisons (for which it's poorly suited), 
        or relying entirely on JavaScript (losing the declarative nature), we use each technology 
        for what it does best.
      </p>
      
      <h3>Relation to Other Range Slider Approaches</h3>
      <p>
        The Domain State Slider represents an evolution from our previous range slider examples:
      </p>
      <ul>
        <li>Unlike the <a href="css-derived-range-slider.html">CSS-Derived Range Slider</a>, it doesn't require verbose selectors for every possible value</li>
        <li>Unlike the <a href="attribute-derived-range-slider.html">Attribute-Derived Range Slider</a>, it makes state domains visually explicit</li>
        <li>It combines the best aspects of both approaches while adding the concept of within-domain positioning</li>
      </ul>
    </section>

    <section class="next-steps">
      <h2>Taking It Further</h2>
      
      <h3>Interactive Domain Boundaries</h3>
      <p>
        One powerful extension would be to make domain boundaries themselves interactive and adjustable:
      </p>
      <ul>
        <li>Allow users to customize where domains begin and end</li>
        <li>Store domain boundaries as part of the application state</li>
        <li>Create visual handles for resizing domain sections</li>
      </ul>
      <p>
        This would enable personalized thresholds tailored to individual user needs or specific application contexts.
      </p>
      
      <h3>Dynamic Domain Sets</h3>
      <p>
        For more advanced applications, consider implementing context-sensitive domain sets:
      </p>
      <ul>
        <li>Swap between different domain configurations based on application mode or context</li>
        <li>Allow selecting between preset domain configurations (e.g., "simple", "advanced")</li>
        <li>Dynamically generate domain sets based on data characteristics or user behavior</li>
      </ul>
      
      <h3>Multi-Layered Domains</h3>
      <p>
        The domain concept can be extended to create nested or overlapping domain structures:
      </p>
      <ul>
        <li>Primary domains for major state categories</li>
        <li>Secondary domains for finer gradations within primary domains</li>
        <li>Overlapping domains to represent multiple dimensions of state</li>
      </ul>
      <p>
        This approach could be particularly useful for complex settings that have multiple aspects
        to consider simultaneously.
      </p>
      
      <h3>State Transitions and Animations</h3>
      <p>
        Enhance the user experience by adding rich transitions between domains:
      </p>
      <ul>
        <li>Domain-specific transition animations when crossing boundaries</li>
        <li>Progress indicators that prepare users for upcoming state changes</li>
        <li>Audio or haptic feedback cues that reinforce domain transitions</li>
      </ul>
      <p>
        These additions can make state changes more perceptible and meaningful to users.
      </p>
      
      <h3>Real-World Applications</h3>
      <p>
        Consider how this pattern could be applied to common real-world scenarios:
      </p>
      <ul>
        <li><strong>Audio Controls</strong>: Domains representing muted, background, conversation, and performance volume levels</li>
        <li><strong>Resource Usage</strong>: Domains for normal, high, and critical resource consumption with different alerting behaviors</li>
        <li><strong>Progress Tracking</strong>: Domains representing preparation, early progress, substantial completion, and finalization phases</li>
      </ul>
      <p>
        Each of these applications would benefit from the domain-based approach by making state changes
        more semantically meaningful and visually explicit.
      </p>
    </section>
    </main>
  </div>

  <footer>
    <div class="container">
      <p>&copy; 2025 UIstate - A declarative state management approach for the web</p>
    </div>
  </footer>
</body>
</html>
