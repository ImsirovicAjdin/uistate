<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS-Derived Range Slider Example - UIstate Documentation</title>
  <link rel="stylesheet" href="main.css">
  <style>
    .demo-container {
      border: 1px solid #e0e0e0;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      background-color: #f9f9f9;
    }
    
    .range-slider-container {
      margin-top: 20px;
      padding: 20px;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background-color: #fff;
      width: 100%;
      max-width: 500px;
    }
    
    .range-label {
      display: block;
      margin-bottom: 15px;
      font-weight: 500;
      font-size: 16px;
    }
    
    .value-display {
      font-weight: 700;
      color: #3498db;
    }
    
    .range-track {
      position: relative;
      height: 6px;
      background-color: #e0e0e0;
      border-radius: 3px;
      cursor: pointer;
      margin: 10px 0;
    }
    
    .range-fill {
      position: absolute;
      height: 100%;
      background-color: #3498db;
      border-radius: 3px;
      pointer-events: none;
      width: var(--slider-position, 50%);
    }
    
    .range-thumb {
      position: absolute;
      width: 20px;
      height: 20px;
      background-color: #fff;
      border: 2px solid #3498db;
      border-radius: 50%;
      top: 50%;
      left: var(--slider-position, 50%);
      transform: translate(-50%, -50%);
      cursor: grab;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    .range-thumb:hover {
      background-color: #f5f5f5;
    }
    
    .range-thumb:active {
      cursor: grabbing;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    /* Intensity level colors */
    .muted .range-fill { background-color: #95a5a6; }
    .muted .value-display { color: #95a5a6; }
    
    .low .range-fill { background-color: #3498db; }
    .low .value-display { color: #3498db; }
    
    .medium .range-fill { background-color: #2980b9; }
    .medium .value-display { color: #2980b9; }
    
    .high .range-fill { background-color: #e67e22; }
    .high .value-display { color: #e67e22; }
    
    .maximum .range-fill { background-color: #e74c3c; }
    .maximum .value-display { color: #e74c3c; font-weight: 700; }

    .code-example {
      background-color: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
    }
    
    .code-example pre {
      margin: 0;
      white-space: pre-wrap;
    }
    
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    
    .comparison-table th, .comparison-table td {
      border: 1px solid #e0e0e0;
      padding: 10px;
      text-align: left;
    }
    
    .comparison-table th {
      background-color: #f5f5f5;
    }
    
    .comparison-table tr:nth-child(even) {
      background-color: #f9f9f9;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>CSS-Derived Range Slider Example</h1>
      <p>Using pure CSS for state derivation with UIstate</p>
    </div>
  </header>

  <div class="container">
    <nav class="breadcrumbs">
      <a href="../index.html">Home</a> &gt;
      <a href="../examples.html">Examples</a> &gt;
      <span>CSS-Derived Range Slider</span>
    </nav>

    <main>
    <section class="intro">
      <h2>Introduction</h2>
      <p>
        This example demonstrates how to create a range slider component using pure CSS for
        state derivation, following the UIstate Cascading Derived State (CDS) principles.
      </p>
      <p>
        Unlike the <a href="attribute-derived-range-slider.html">Attribute-Derived Range Slider</a>
        which uses JavaScript to derive intensity categories, this example derives state entirely
        through CSS selectors, showcasing the power of CSS as a computational layer.
      </p>
      <p>
        This approach pushes CSS to its limits, demonstrating how far you can go with pure
        declarative state derivation without relying on JavaScript.
      </p>
    </section>

    <section class="demo">
      <h2>Live Demo</h2>
      <div class="demo-container">
        <div class="range-slider-container" id="demo-slider" data-uis-value="50" data-uis-min="0" data-uis-max="100">
          <label class="range-label">Volume: <span class="value-display">50</span></label>
          <div class="range-track">
            <div class="range-fill"></div>
            <div class="range-thumb"></div>
          </div>
        </div>
      </div>

      <script>
        // Demo implementation
        document.addEventListener('DOMContentLoaded', function() {
          // Get references to elements
          const container = document.querySelector('#demo-slider');
          const valueDisplay = container.querySelector('.value-display');
          const thumb = container.querySelector('.range-thumb');
          const track = container.querySelector('.range-track');
          
          // Initialize from data attributes
          updateSliderPosition();
          updateIntensityLevel();
          
          // Add event listeners for mouse/touch interactions
          thumb.addEventListener('mousedown', startDrag);
          track.addEventListener('click', jumpToPosition);
          
          // Function to start dragging the thumb
          function startDrag(e) {
            e.preventDefault();
            
            // Add event listeners for drag and release
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Store initial position for drag calculation
            const initialX = e.clientX;
            const initialValue = parseInt(container.getAttribute('data-uis-value'));
            
            // Drag function
            function drag(e) {
              const trackRect = track.getBoundingClientRect();
              const min = parseInt(container.getAttribute('data-uis-min'));
              const max = parseInt(container.getAttribute('data-uis-max'));
              const trackWidth = trackRect.width;
              
              // Calculate new position based on drag distance
              const dragDistance = e.clientX - initialX;
              const dragRatio = dragDistance / trackWidth;
              const valueRange = max - min;
              const valueDelta = dragRatio * valueRange;
              
              // Calculate new value and constrain to min/max
              let newValue = Math.round(initialValue + valueDelta);
              newValue = Math.max(min, Math.min(max, newValue));
              
              // Update the data attribute (source of truth)
              container.setAttribute('data-uis-value', newValue);
              
              // Update the UI
              updateSliderPosition();
              updateIntensityLevel();
            }
            
            // Stop drag function
            function stopDrag() {
              document.removeEventListener('mousemove', drag);
              document.removeEventListener('mouseup', stopDrag);
            }
          }
          
          // Function to jump to clicked position
          function jumpToPosition(e) {
            const trackRect = track.getBoundingClientRect();
            const min = parseInt(container.getAttribute('data-uis-min'));
            const max = parseInt(container.getAttribute('data-uis-max'));
            const trackWidth = trackRect.width;
            
            // Calculate click position relative to track
            const clickX = e.clientX - trackRect.left;
            const clickRatio = clickX / trackWidth;
            
            // Calculate new value and constrain to min/max
            let newValue = Math.round(min + clickRatio * (max - min));
            newValue = Math.max(min, Math.min(max, newValue));
            
            // Update the data attribute (source of truth)
            container.setAttribute('data-uis-value', newValue);
            
            // Update the UI
            updateSliderPosition();
            updateIntensityLevel();
          }
          
          // Function to update slider position based on data attribute
          function updateSliderPosition() {
            const value = parseInt(container.getAttribute('data-uis-value'));
            const min = parseInt(container.getAttribute('data-uis-min'));
            const max = parseInt(container.getAttribute('data-uis-max'));
            
            // Calculate position percentage
            const percentage = ((value - min) / (max - min)) * 100;
            
            // Update CSS variable
            document.documentElement.style.setProperty('--slider-position', `${percentage}%`);
            
            // Update value display
            valueDisplay.textContent = value;
          }
          
          // Function to update intensity level based on the current value
          function updateIntensityLevel() {
            const value = parseInt(container.getAttribute('data-uis-value'));
            
            // Determine intensity level
            let intensityLevel = '';
            if (value <= 10) {
              intensityLevel = 'muted';
            } else if (value <= 30) {
              intensityLevel = 'low';
            } else if (value <= 70) {
              intensityLevel = 'medium';
            } else if (value <= 85) {
              intensityLevel = 'high';
            } else {
              intensityLevel = 'maximum';
            }
            
            // Update the intensity level style property
            container.style.setProperty('--intensity-level', `"${intensityLevel}"`);
            
            // For demonstration in the docs, add a class
            container.classList.remove('muted', 'low', 'medium', 'high', 'maximum');
            container.classList.add(intensityLevel);
          }
        });
      </script>
    </section>

    <section class="implementation">
      <h2>Implementation Walkthrough</h2>
      
      <h3>HTML Structure</h3>
      <p>
        The range slider consists of a container with data attributes for state,
        a label with value display, and the slider components (track, fill, and thumb).
      </p>
      <div class="code-example">
        <pre><code>&lt;div class="range-slider-container" data-uis-value="50" data-uis-min="0" data-uis-max="100"&gt;
  &lt;label class="range-label"&gt;Volume: &lt;span class="value-display"&gt;50&lt;/span&gt;&lt;/label&gt;
  &lt;div class="range-track"&gt;
    &lt;div class="range-fill"&gt;&lt;/div&gt;
    &lt;div class="range-thumb"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
      </div>
      <p>
        Notice there is no additional attribute for the derived intensity level –
        this is derived entirely through CSS selectors.
      </p>
      
      <h3>CSS for State Derivation</h3>
      <p>
        The key aspect of this approach is using CSS selectors to derive intensity levels
        based on value ranges:
      </p>
      <div class="code-example">
        <pre><code>/* Derived state: intensity levels based on value ranges */
.range-slider-container[data-uis-value="0"],
.range-slider-container[data-uis-value="1"],
.range-slider-container[data-uis-value="2"],
/* ... more values ... */
.range-slider-container[data-uis-value="10"] {
  --intensity-level: "muted";
}

.range-slider-container[data-uis-value="11"],
.range-slider-container[data-uis-value="12"],
/* ... more values ... */
.range-slider-container[data-uis-value="30"] {
  --intensity-level: "low";
}

/* Additional ranges for other intensity levels... */</code></pre>
      </div>
      <p>
        This approach lists every possible value within each intensity category,
        setting a CSS custom property that can then be used for styling.
      </p>
      
      <h3>Applying Styles Based on Derived State</h3>
      <p>
        Once the intensity level is derived, styles are applied based on this derived state:
      </p>
      <div class="code-example">
        <pre><code>/* Apply styles based on intensity level */
.range-slider-container[style*="--intensity-level: \"muted\""] .range-fill {
  background-color: #95a5a6;
}

.range-slider-container[style*="--intensity-level: \"low\""] .range-fill {
  background-color: #3498db;
}

/* More styles for other intensity levels... */</code></pre>
      </div>
      <p>
        This creates a cascading derivation: from raw value to intensity level to visual styles.
      </p>
      
      <h3>JavaScript for Event Handling</h3>
      <p>
        The JavaScript handles user interactions and updates the raw value, but importantly,
        it doesn't compute the derived state – that's handled entirely by CSS:
      </p>
      <div class="code-example">
        <pre><code>// Update the data attribute (source of truth)
container.setAttribute('data-uis-value', newValue);

// Update the UI (position and display)
updateSliderPosition();</code></pre>
      </div>
      <p>
        The derived state updates automatically as a result of the CSS selectors
        when the data-uis-value attribute changes.
      </p>
    </section>

    <section class="key-insights">
      <h2>Key Insights</h2>
      
      <h3>Pure CSS State Derivation</h3>
      <p>
        This example demonstrates the power of CSS as a computational layer for state derivation.
        By using complex selectors, CSS can derive categorical states from numeric values without
        any JavaScript computation.
      </p>
      
      <h3>Cascading Derived State (CDS)</h3>
      <p>
        The state flows through multiple layers:
      </p>
      <ol>
        <li>Raw numeric value stored in data-uis-value attribute</li>
        <li>Derived intensity level stored in --intensity-level CSS property</li>
        <li>Visual styles applied based on the derived intensity level</li>
      </ol>
      <p>
        This cascade of derivations is handled entirely within CSS, showcasing the power of the CDS approach.
      </p>
      
      <h3>Tradeoffs of Pure CSS Approach</h3>
      <p>
        While powerful, this approach has some considerations:
      </p>
      <ul>
        <li><strong>Verbose Selectors</strong>: Listing every possible value can lead to lengthy CSS</li>
        <li><strong>Maintenance Overhead</strong>: Changing ranges requires updating many selectors</li>
        <li><strong>Performance Considerations</strong>: Large number of selectors may impact style recalculation</li>
      </ul>
      <p>
        These tradeoffs are acceptable for educational purposes and simple components,
        but for complex applications, the attribute-derived approach might be more practical.
      </p>
      
      <h3>CSS vs. JavaScript for State Derivation</h3>
      <p>
        This example compared to the attribute-derived approach highlights an important distinction:
      </p>
      <table class="comparison-table">
        <tr>
          <th>Criteria</th>
          <th>CSS-Derived (This Example)</th>
          <th>Attribute-Derived</th>
        </tr>
        <tr>
          <td>Purity of Approach</td>
          <td>Pure CSS, no state computation in JS</td>
          <td>Uses JS for state computation, CSS for styling</td>
        </tr>
        <tr>
          <td>Code Verbosity</td>
          <td>More verbose (many selectors)</td>
          <td>More concise (fewer selectors)</td>
        </tr>
        <tr>
          <td>State Visibility</td>
          <td>Derived state only visible in CSS</td>
          <td>Derived state visible in HTML attributes</td>
        </tr>
        <tr>
          <td>Maintenance</td>
          <td>Harder to maintain for complex ranges</td>
          <td>Easier to maintain for complex ranges</td>
        </tr>
        <tr>
          <td>Educational Value</td>
          <td>Demonstrates the power of CSS</td>
          <td>Demonstrates practical state management</td>
        </tr>
      </table>
    </section>

    <section class="relationship-to-uistate">
      <h2>Relationship to UIstate Philosophy</h2>
      <p>
        This example embodies the core UIstate principle of using CSS as a computational layer
        for state derivation. It demonstrates that with careful design, CSS alone can handle
        complex state relationships traditionally delegated to JavaScript.
      </p>
      <p>
        The pure CSS approach showcases the ultimate expression of the Cascading Derived
        State (CDS) concept, where all state transformations happen within CSS, keeping
        JavaScript focused solely on event handling and DOM updates.
      </p>
      <p>
        For simple components or educational purposes, this pure approach clearly demonstrates
        the power of CSS. For more complex applications, the hybrid attribute-derived approach
        might offer a better balance of declarative styling and maintainable code.
      </p>
    </section>

    <section class="when-to-use">
      <h2>When to Use This Approach</h2>
      <p>
        The CSS-derived approach is particularly well-suited for:
      </p>
      <ul>
        <li>Educational demonstrations of CSS capabilities</li>
        <li>Simple components with few possible values</li>
        <li>Projects where JavaScript should be absolutely minimized</li>
        <li>Scenarios where state derivation logic is simple and unlikely to change</li>
      </ul>
      <p>
        Consider the attribute-derived approach for:
      </p>
      <ul>
        <li>Components with many possible values</li>
        <li>Complex derivation logic that would be verbose in CSS</li>
        <li>Projects where code maintainability is a priority</li>
        <li>Components that require explicit representation of derived state</li>
      </ul>
    </section>

    <section class="next-steps">
      <h2>Taking It Further</h2>
      <p>This example demonstrates a basic CSS-derived range slider. You could extend it by:</p>
      <ul>
        <li>Adding more derived properties beyond just intensity level</li>
        <li>Creating multiple interdependent components that react to the same state</li>
        <li>Exploring techniques to reduce the verbosity of CSS selectors</li>
        <li>Comparing performance between CSS-derived and attribute-derived approaches</li>
      </ul>
      <p>
        Also consider exploring the <a href="attribute-derived-range-slider.html">Attribute-Derived Range Slider</a>
        example to understand the alternative approach and its tradeoffs.
      </p>
    </section>
    </main>
  </div>

  <footer>
    <div class="container">
      <p>&copy; 2025 UIstate - A declarative state management approach for the web</p>
    </div>
  </footer>
</body>
</html>
