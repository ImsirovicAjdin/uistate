<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Calc-Derived Range Slider Example - UIstate Documentation</title>
  <link rel="stylesheet" href="main.css">
  <style>
    .demo-container {
      border: 1px solid #e0e0e0;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      background-color: #f9f9f9;
    }
    
    .code-example {
      background-color: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 15px;
      margin: 15px 0;
      overflow-x: auto;
    }
    
    .code-example pre {
      margin: 0;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Calc-Derived Range Slider Example</h1>
      <p>Pure CSS state derivation using calc() and custom properties</p>
    </div>
  </header>

  <div class="container">
    <nav class="breadcrumbs">
      <a href="../index.html">Home</a> &gt;
      <a href="../examples.html">Examples</a> &gt;
      <span>Calc-Derived Range Slider</span>
    </nav>

    <main>
    <section class="intro">
      <h2>Introduction</h2>
      <p>
        The Calc-Derived Range Slider demonstrates the extraordinary power of modern CSS 
        to handle complex state derivation entirely through calculated properties, with minimal JavaScript.
      </p>
      
      <h3>The Calc-Based Approach</h3>
      <p>
        This example pushes the boundaries of what's possible with CSS by creating a complete state 
        derivation system using only CSS variables and calc() functions. It represents the most 
        declarative approach of all our range slider examples:
      </p>
      <ul>
        <li>The raw slider value is the source of truth (stored as a data attribute)</li>
        <li>CSS calc() functions determine which domain the value falls into</li>
        <li>All derived state (colors, text, animations) is calculated purely in CSS</li>
        <li>JavaScript's only role is to update the raw value attribute</li>
      </ul>
      
      <h3>Key Benefits</h3>
      <p>
        This calc-based approach offers several unique advantages:
      </p>
      <ul>
        <li><strong>Thread Isolation</strong> - CSS runs on a separate thread from JavaScript, improving performance</li>
        <li><strong>Declarative Purity</strong> - The entire state derivation model is expressed declaratively</li>
        <li><strong>Runtime Efficiency</strong> - Browser engines are highly optimized for CSS calculation</li>
        <li><strong>Self-Contained</strong> - The style system manages its own state without JavaScript dependencies</li>
        <li><strong>Progressive Enhancement</strong> - Clean separation between core value and derived presentations</li>
      </ul>
    </section>

    <section class="implementation">
      <h2>Implementation Walkthrough</h2>
      
      <h3>CSS Variables as a State Machine</h3>
      <p>
        The core innovation in this approach is using CSS variables to create a virtual state machine:
      </p>
      <div class="code-example">
        <pre><code>:root {
  /* Base value from JS */
  --slider-raw-value: 50;
  
  /* Domain boundaries */
  --domain-muted-min: 0;
  --domain-muted-max: 10;
  /* Additional domain boundaries... */
  
  /* CSS-only domain detection using calc() ternary operations */
  --is-in-muted: clamp(0, 
    calc(
      (var(--slider-raw-value) >= var(--domain-muted-min)) * 
      (var(--slider-raw-value) <= var(--domain-muted-max))
    ), 1);
  
  /* Additional domain detection variables... */
}</code></pre>
      </div>
      
      <h3>Boolean Logic in CSS</h3>
      <p>
        We implement boolean logic operations using multiplication. In CSS calc():
      </p>
      <ul>
        <li>Multiplication acts like a logical AND</li>
        <li>Addition with negation can act like a logical OR</li>
        <li>Conditions evaluate to 1 (true) or 0 (false)</li>
      </ul>
      <div class="code-example">
        <pre><code>/* This is effectively: if value >= min AND value <= max then 1 else 0 */
--is-in-medium: clamp(0, 
  calc(
    (var(--slider-raw-value) >= var(--domain-medium-min)) * 
    (var(--slider-raw-value) <= var(--domain-medium-max))
  ), 1);</code></pre>
      </div>
      
      <h3>Dynamic Text Generation</h3>
      <p>
        Perhaps the most surprising capability is generating text content based on state:
      </p>
      <div class="code-example">
        <pre><code>.current-domain::before {
  content: 
    var(--is-in-muted) * "Muted" + 
    var(--is-in-low) * "Low" + 
    var(--is-in-medium) * "Medium" + 
    var(--is-in-high) * "High" + 
    var(--is-in-maximum) * "Maximum";
}</code></pre>
      </div>
      <p>
        Since only one domain variable will be 1 and the rest 0, only one string appears in the content.
      </p>
      
      <h3>HTML Structure</h3>
      <p>
        The HTML structure is remarkably clean, with only a single data attribute needed:
      </p>
      <div class="code-example">
        <pre><code>&lt;div class="calc-slider-container" data-uis-value="50" data-uis-min="0" data-uis-max="100"&gt;
  &lt;!-- Domain visualization --&gt;
  &lt;div class="domain-sections"&gt;...&lt;/div&gt;
  
  &lt;!-- Slider components --&gt;
  &lt;div class="slider-track"&gt;
    &lt;div class="slider-fill"&gt;&lt;/div&gt;
    &lt;div class="slider-thumb"&gt;&lt;/div&gt;
  &lt;/div&gt;
  
  &lt;!-- User feedback elements --&gt;
  &lt;div class="value-display"&gt;
    &lt;div class="current-value"&gt;&lt;/div&gt;
    &lt;div class="current-domain"&gt;&lt;/div&gt;
  &lt;/div&gt;
  
  &lt;div class="domain-indicator"&gt;...&lt;/div&gt;
&lt;/div&gt;</code></pre>
      </div>
    </section>

    <section class="key-insights">
      <h2>Key Insights</h2>
      
      <h3>CSS as a Computational Layer</h3>
      <p>
        This example challenges the conventional view of CSS as merely a styling language. 
        It demonstrates that CSS can function as a powerful computational layer for:
      </p>
      <ul>
        <li>Conditional logic</li>
        <li>State derivation</li>
        <li>Dynamic content generation</li>
        <li>Complex calculations</li>
      </ul>
      
      <h3>Progressive Separation of Concerns</h3>
      <p>
        The Calc-Derived approach takes separation of concerns to a new level:
      </p>
      <ul>
        <li>HTML: Core data structure</li>
        <li>JavaScript: Input handling and minimal state bridging</li>
        <li>CSS: All state derivation and styling</li>
      </ul>
      <p>
        Each layer has a clearly defined responsibility with minimal coupling.
      </p>
      
      <h3>Benefits and Trade-offs</h3>
      <p>
        Compared to other range slider approaches:
      </p>
      <table>
        <tr>
          <th>Approach</th>
          <th>State Derivation</th>
          <th>Advantages</th>
          <th>Limitations</th>
        </tr>
        <tr>
          <td>CSS-Derived</td>
          <td>Selection-based</td>
          <td>Simple, pure CSS</td>
          <td>Verbose for many values</td>
        </tr>
        <tr>
          <td>Attribute-Derived</td>
          <td>JavaScript to attributes</td>
          <td>Concise, flexible</td>
          <td>Requires JS for state changes</td>
        </tr>
        <tr>
          <td>Domain State</td>
          <td>Domain-based +<br/>position within domain</td>
          <td>Semantic, visual domains</td>
          <td>Requires JS for domain calculation</td>
        </tr>
        <tr>
          <td>Calc-Derived</td>
          <td>CSS calc() functions</td>
          <td>Thread isolated, declarative</td>
          <td>Complex CSS, debugging challenges</td>
        </tr>
      </table>
    </section>

    <section class="next-steps">
      <h2>Taking It Further</h2>
      
      <h3>Combining with Other Techniques</h3>
      <p>
        The calc-based approach could be enhanced by combining it with other UIstate techniques:
      </p>
      <ul>
        <li>Use with CSS @property for type checking and transition control</li>
        <li>Integrate with CSS custom counter for more complex numeric displays</li>
        <li>Combine with CSS grid or flexbox for responsive state visualization</li>
      </ul>
      
      <h3>Potential Applications</h3>
      <p>
        This technique is particularly valuable for:
      </p>
      <ul>
        <li>Performance-critical UIs where offloading computation to CSS improves responsiveness</li>
        <li>Applications where JavaScript might be throttled or deprioritized</li>
        <li>Highly interactive components that need to maintain smooth animations during state changes</li>
        <li>Progressive web apps that need to minimize JavaScript overhead</li>
      </ul>
      
      <h3>Advanced CSS Logic</h3>
      <p>
        The approach could be extended with even more sophisticated CSS logic:
      </p>
      <ul>
        <li>Implement full decision trees using nested calc expressions</li>
        <li>Create multi-condition state derivation for complex business rules</li>
        <li>Use CSS filters and blend modes for advanced visual state representation</li>
      </ul>
      
      <p>
        While this approach pushes CSS to its limits, it demonstrates the untapped potential 
        of modern CSS as a declarative programming language for UI state management.
      </p>
    </section>
    </main>
  </div>

  <footer>
    <div class="container">
      <p>&copy; 2025 UIstate - A declarative state management approach for the web</p>
    </div>
  </footer>
</body>
</html>
